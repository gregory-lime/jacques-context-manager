/**
 * Subagent Store
 *
 * Manages storage and retrieval of archived subagent conversations.
 * Subagents are stored separately from main sessions because Claude Code
 * stores their conversations in separate JSONL files.
 *
 * Storage structure:
 *   ~/.jacques/archive/subagents/{agentId}.json
 */

import { promises as fs } from "fs";
import * as path from "path";
import { homedir } from "os";
import type { DisplayMessage } from "../session/transformer.js";

/** Archive directory for subagents */
const SUBAGENTS_DIR = path.join(
  homedir(),
  ".jacques",
  "archive",
  "subagents"
);

/**
 * Token statistics for a subagent conversation
 */
export interface SubagentTokenStats {
  totalInput: number;
  totalOutput: number;
  cacheCreation?: number;
  cacheRead?: number;
}

/**
 * Archived subagent conversation
 */
export interface ArchivedSubagent {
  /** Agent ID (e.g., "a0323e0") */
  id: string;
  /** Parent session ID */
  sessionId: string;
  /** Project slug for context */
  projectSlug: string;
  /** ISO timestamp when archived */
  archivedAt: string;
  /** Task prompt given to the agent */
  prompt: string;
  /** Model used (e.g., "claude-haiku-4-5") */
  model?: string;
  /** Full conversation messages */
  conversation: DisplayMessage[];
  /** Statistics about the subagent conversation */
  statistics: {
    messageCount: number;
    toolCallCount: number;
    tokens: SubagentTokenStats;
    durationMs?: number;
  };
}

/**
 * Reference to a subagent stored in the archive
 * Used in manifests and indexes to link to full content
 */
export interface SubagentReference {
  /** Agent ID */
  id: string;
  /** Parent session ID */
  sessionId: string;
  /** Truncated prompt preview (max 100 chars) */
  promptPreview: string;
  /** Model used */
  model?: string;
  /** Total tokens used */
  tokenCount: number;
  /** Number of messages in the conversation */
  messageCount: number;
  /** Position in parent conversation */
  position: {
    /** UUID of the preceding message in parent session */
    afterMessageUuid?: string;
    /** Index in the parent conversation */
    index: number;
  };
}

/**
 * Ensure the subagents archive directory exists
 */
async function ensureSubagentsDir(): Promise<void> {
  await fs.mkdir(SUBAGENTS_DIR, { recursive: true });
}

/**
 * Get the file path for a subagent archive
 */
function getSubagentPath(agentId: string): string {
  return path.join(SUBAGENTS_DIR, `${agentId}.json`);
}

/**
 * Archive a subagent conversation
 */
export async function archiveSubagent(
  subagent: ArchivedSubagent
): Promise<void> {
  await ensureSubagentsDir();
  const filePath = getSubagentPath(subagent.id);
  await fs.writeFile(filePath, JSON.stringify(subagent, null, 2), "utf-8");
}

/**
 * Read a subagent from the archive
 */
export async function readSubagent(
  agentId: string
): Promise<ArchivedSubagent | null> {
  const filePath = getSubagentPath(agentId);
  try {
    const content = await fs.readFile(filePath, "utf-8");
    return JSON.parse(content) as ArchivedSubagent;
  } catch {
    return null;
  }
}

/**
 * List all subagents for a given session
 */
export async function listSubagentsForSession(
  sessionId: string
): Promise<ArchivedSubagent[]> {
  try {
    await ensureSubagentsDir();
    const files = await fs.readdir(SUBAGENTS_DIR);
    const subagents: ArchivedSubagent[] = [];

    for (const file of files) {
      if (!file.endsWith(".json")) continue;
      const filePath = path.join(SUBAGENTS_DIR, file);
      try {
        const content = await fs.readFile(filePath, "utf-8");
        const subagent = JSON.parse(content) as ArchivedSubagent;
        if (subagent.sessionId === sessionId) {
          subagents.push(subagent);
        }
      } catch {
        // Skip invalid files
      }
    }

    return subagents;
  } catch {
    return [];
  }
}

/**
 * Check if a subagent is already archived
 */
export async function isSubagentArchived(agentId: string): Promise<boolean> {
  const filePath = getSubagentPath(agentId);
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * List all subagent IDs in the archive
 */
export async function listAllSubagentIds(): Promise<string[]> {
  try {
    await ensureSubagentsDir();
    const files = await fs.readdir(SUBAGENTS_DIR);
    return files
      .filter((f) => f.endsWith(".json"))
      .map((f) => path.basename(f, ".json"));
  } catch {
    return [];
  }
}

/**
 * Create a SubagentReference from an ArchivedSubagent
 * Token counts include:
 *   - totalInput: non-cached input tokens
 *   - cacheCreation: new tokens written to cache
 *   - cacheRead: tokens read from cache
 *   - totalOutput: tokens generated by Claude
 */
export function createSubagentReference(
  subagent: ArchivedSubagent,
  positionIndex: number,
  afterMessageUuid?: string
): SubagentReference {
  const tokens = subagent.statistics.tokens;
  // Total context = input + cache creation + cache read
  const totalContext =
    tokens.totalInput +
    (tokens.cacheCreation ?? 0) +
    (tokens.cacheRead ?? 0);
  // Total tokens includes output
  const totalTokens = totalContext + tokens.totalOutput;

  return {
    id: subagent.id,
    sessionId: subagent.sessionId,
    promptPreview:
      subagent.prompt.length > 100
        ? subagent.prompt.slice(0, 97) + "..."
        : subagent.prompt,
    model: subagent.model,
    tokenCount: totalTokens,
    messageCount: subagent.statistics.messageCount,
    position: {
      afterMessageUuid,
      index: positionIndex,
    },
  };
}

/**
 * Delete a subagent from the archive
 */
export async function deleteSubagent(agentId: string): Promise<boolean> {
  const filePath = getSubagentPath(agentId);
  try {
    await fs.unlink(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Get statistics about the subagent archive
 */
export async function getSubagentArchiveStats(): Promise<{
  totalSubagents: number;
  totalTokens: number;
  bySession: Map<string, number>;
}> {
  const ids = await listAllSubagentIds();
  let totalTokens = 0;
  const bySession = new Map<string, number>();

  for (const id of ids) {
    const subagent = await readSubagent(id);
    if (subagent) {
      const tokens =
        subagent.statistics.tokens.totalInput +
        subagent.statistics.tokens.totalOutput;
      totalTokens += tokens;

      const sessionCount = bySession.get(subagent.sessionId) || 0;
      bySession.set(subagent.sessionId, sessionCount + 1);
    }
  }

  return {
    totalSubagents: ids.length,
    totalTokens,
    bySession,
  };
}
