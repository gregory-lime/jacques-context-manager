/**
 * Claude Operations Logger
 *
 * Logs Claude Code CLI operations to ~/.jacques/logs/claude-operations.jsonl
 * for debugging and visibility into LLM handoff token usage.
 */

import { promises as fs } from "fs";
import { join, dirname } from "path";
import { homedir } from "os";
import { randomUUID } from "crypto";

/**
 * Represents a Claude Code CLI operation (e.g., LLM handoff)
 */
export interface ClaudeOperation {
  /** Unique identifier for this operation */
  id: string;
  /** ISO timestamp when operation started */
  timestamp: string;
  /** Operation type (e.g., "llm-handoff") */
  operation: string;
  /** Phase: "start" when beginning, "complete" when done */
  phase: "start" | "complete";
  /** Input tokens used by the LLM */
  inputTokens: number;
  /** Output tokens generated by the LLM */
  outputTokens: number;
  /** Total tokens (input + output) */
  totalTokens: number;
  /** Cache read tokens (if any) */
  cacheReadTokens?: number;
  /** Duration in milliseconds */
  durationMs: number;
  /** Whether the operation succeeded */
  success: boolean;
  /** Error message if operation failed */
  errorMessage?: string;
  /** Character count of user prompt */
  userPromptChars: number;
  /** Character count of system prompt */
  systemPromptChars: number;
  /** Estimated tokens for user prompt (~4 chars/token) */
  userPromptTokensEst?: number;
  /** Estimated tokens for system prompt (~4 chars/token) */
  systemPromptTokensEst?: number;
  /** Output content length (chars) */
  outputLength?: number;
  /** Truncated preview of user prompt (first 200 chars) */
  userPromptPreview?: string;
  /** Truncated preview of system prompt (first 200 chars) */
  systemPromptPreview?: string;
  /** Debug mode only: the actual user prompt */
  userPrompt?: string;
  /** Debug mode only: the actual system prompt */
  systemPrompt?: string;
  /** Tools called during this operation (for "complete" phase) */
  toolsCalled?: string[];
}

/** Path to the log file */
const LOG_DIR = join(homedir(), ".jacques", "logs");
const LOG_FILE = join(LOG_DIR, "claude-operations.jsonl");
const DEBUG_DIR = join(LOG_DIR, "debug");

/** Enable debug mode to log full prompts (set JACQUES_DEBUG=1) */
const DEBUG_MODE = process.env.JACQUES_DEBUG === "1";

/**
 * Debug data for a Claude operation
 */
export interface ClaudeOperationDebug {
  operationId: string;
  timestamp: string;
  userPrompt: string;
  systemPrompt: string;
  cliArgs: string[];
  cliEvents: unknown[];
  response?: string;
}

/**
 * Claude Operations Logger
 *
 * Provides file-based logging and event emission for real-time broadcast.
 */
export class ClaudeOperationLogger {
  /**
   * Optional callback for real-time broadcast to WebSocket clients.
   * Set this from server/src/start-server.ts to wire up WebSocket broadcast.
   */
  static onOperation?: (op: ClaudeOperation) => void;

  /**
   * Log a Claude operation to file and emit for broadcast
   */
  static async log(operation: ClaudeOperation): Promise<void> {
    try {
      // Ensure log directory exists
      await fs.mkdir(LOG_DIR, { recursive: true });

      // Append to JSONL file
      const line = JSON.stringify(operation) + "\n";
      await fs.appendFile(LOG_FILE, line, "utf-8");

      // Emit for real-time broadcast (strip debug fields for broadcast)
      if (ClaudeOperationLogger.onOperation) {
        const broadcastOp = { ...operation };
        // Don't broadcast full prompts even in debug mode
        delete broadcastOp.userPrompt;
        delete broadcastOp.systemPrompt;
        ClaudeOperationLogger.onOperation(broadcastOp);
      }
    } catch (error) {
      // Log to stderr but don't throw - logging shouldn't break the operation
      console.error(
        `[ClaudeOperationLogger] Failed to log operation: ${error}`
      );
    }
  }

  /**
   * Save debug data to a file for detailed inspection
   * Creates: ~/.jacques/logs/debug/{operationId}.json
   */
  static async saveDebugData(data: ClaudeOperationDebug): Promise<string> {
    try {
      await fs.mkdir(DEBUG_DIR, { recursive: true });
      const filename = `${data.operationId}.json`;
      const filepath = join(DEBUG_DIR, filename);
      await fs.writeFile(filepath, JSON.stringify(data, null, 2), "utf-8");
      return filepath;
    } catch (error) {
      console.error(`[ClaudeOperationLogger] Failed to save debug data: ${error}`);
      return "";
    }
  }

  /**
   * Read debug data for an operation
   */
  static async readDebugData(operationId: string): Promise<ClaudeOperationDebug | null> {
    try {
      const filepath = join(DEBUG_DIR, `${operationId}.json`);
      const content = await fs.readFile(filepath, "utf-8");
      return JSON.parse(content);
    } catch {
      return null;
    }
  }

  /**
   * Get the debug file path for an operation
   */
  static getDebugFilePath(operationId: string): string {
    return join(DEBUG_DIR, `${operationId}.json`);
  }

  /**
   * Get recent operations from the log file
   */
  static async getRecentOperations(limit = 50): Promise<ClaudeOperation[]> {
    try {
      const content = await fs.readFile(LOG_FILE, "utf-8");
      const lines = content.trim().split("\n").filter(Boolean);

      // Parse and return last N operations
      const operations: ClaudeOperation[] = [];
      const startIndex = Math.max(0, lines.length - limit);

      for (let i = startIndex; i < lines.length; i++) {
        try {
          operations.push(JSON.parse(lines[i]));
        } catch {
          // Skip malformed lines
        }
      }

      return operations;
    } catch (error) {
      // File doesn't exist yet or other error
      return [];
    }
  }

  /**
   * Create a new operation ID
   */
  static createOperationId(): string {
    return randomUUID();
  }

  /**
   * Check if debug mode is enabled
   */
  static isDebugMode(): boolean {
    return DEBUG_MODE;
  }

  /**
   * Get the log file path
   */
  static getLogPath(): string {
    return LOG_FILE;
  }
}
