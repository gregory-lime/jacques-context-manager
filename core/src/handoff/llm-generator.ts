/**
 * LLM Handoff Generator
 *
 * Generates handoff documents using Claude Code CLI with the jacques-handoff skill.
 * This provides higher-quality, AI-powered extraction compared to the rule-based generator.
 */

import { spawn, type ChildProcess } from "child_process";
import { promises as fs, appendFileSync } from "fs";
import { join } from "path";
import { homedir } from "os";
import { ensureHandoffsDir, generateHandoffFilename } from "./catalog.js";
import { getCompactContextForSkill } from "./generator.js";
import { ClaudeOperationLogger, type ClaudeOperation, type ClaudeOperationDebug } from "../logging/index.js";

/** Path to the jacques-handoff skill file */
const SKILL_PATH = join(homedir(), ".claude/skills/jacques-handoff/SKILL.md");

/** Default timeout for Claude Code CLI (5 minutes - handoffs can take a while for long conversations) */
const DEFAULT_TIMEOUT = 300000;

/** Enable debug logging for streaming events */
const DEBUG_STREAMING = process.env.JACQUES_DEBUG_STREAMING === "1";

/** Debug log file path */
const DEBUG_LOG_FILE = "/tmp/jacques-streaming-debug.log";

/** Write debug message to file */
function debugLog(message: string): void {
  if (!DEBUG_STREAMING) return;
  const timestamp = new Date().toISOString();
  const line = `[${timestamp}] ${message}\n`;
  // Sync write to ensure we see output immediately
  try {
    appendFileSync(DEBUG_LOG_FILE, line);
  } catch {
    // Ignore write errors
  }
}

/**
 * Result of LLM-powered handoff generation
 */
export interface LLMHandoffResult {
  /** Full path to the generated handoff file */
  filePath: string;
  /** Filename of the handoff */
  filename: string;
  /** The handoff content */
  content: string;
  /** Input tokens used by the LLM */
  inputTokens: number;
  /** Output tokens generated by the LLM */
  outputTokens: number;
  /** Total tokens used */
  totalTokens: number;
}

/**
 * Error thrown when Claude Code CLI fails
 */
export class ClaudeCodeError extends Error {
  constructor(
    message: string,
    public readonly exitCode?: number,
    public readonly stderr?: string
  ) {
    super(message);
    this.name = "ClaudeCodeError";
  }
}

/**
 * Callbacks for streaming LLM output
 */
export interface LLMStreamCallbacks {
  /** Called when new text is generated */
  onTextDelta?: (text: string) => void;
  /** Called when token counts are updated */
  onTokenUpdate?: (inputTokens: number, outputTokens: number) => void;
  /** Called when a new processing stage begins */
  onStage?: (stage: string) => void;
}

/**
 * Options for generateHandoffWithLLM
 */
export interface LLMHandoffOptions {
  /** Timeout in milliseconds (default: 120000) */
  timeout?: number;
  /** AbortSignal for cancellation */
  signal?: AbortSignal;
  /** Callbacks for streaming output */
  stream?: LLMStreamCallbacks;
}

/**
 * Handle a streaming event from Claude Code CLI
 *
 * Event structure (with --include-partial-messages):
 * - type: "stream_event", event.type: "message_start" - initial token count
 * - type: "stream_event", event.type: "content_block_delta" - text chunks (delta.text)
 * - type: "stream_event", event.type: "message_delta" - final usage
 * - type: "result" - final result with total usage
 */
function handleStreamEvent(
  event: Record<string, unknown>,
  callbacks?: LLMStreamCallbacks,
  state?: { inputTokens: number; outputTokens: number }
): void {
  if (!callbacks) {
    debugLog(`[EVENT] NO CALLBACKS - skipping event type=${event.type}`);
    return;
  }

  debugLog(`[EVENT] type=${event.type} callbacks.onTextDelta=${!!callbacks.onTextDelta} callbacks.onTokenUpdate=${!!callbacks.onTokenUpdate}`);

  // Handle stream_event wrapper
  if (event.type === "stream_event") {
    const inner = event.event as Record<string, unknown> | undefined;
    if (!inner) return;

    debugLog(`[STREAM] inner.type=${inner.type}`);

    // Content block start - could be text or tool_use
    // Structure: { type: "content_block_start", content_block: { type: "text" | "tool_use", ... } }
    if (inner.type === "content_block_start") {
      const contentBlock = inner.content_block as { type?: string; name?: string } | undefined;
      debugLog(`[BLOCK_START] type=${contentBlock?.type} name=${contentBlock?.name}`);
      // Notify when a tool starts being used
      if (contentBlock?.type === "tool_use" && contentBlock.name) {
        callbacks.onStage?.(`Using ${contentBlock.name}...`);
      }
    }

    // Text delta - partial text as it's generated
    // Structure: { type: "content_block_delta", delta: { type: "text_delta", text: "..." } }
    if (inner.type === "content_block_delta") {
      const delta = inner.delta as { type?: string; text?: string; partial_json?: string } | undefined;
      debugLog(`[DELTA] type=${delta?.type} text=${delta?.text?.substring(0, 50)} json=${delta?.partial_json?.substring(0, 50)}`);
      if (delta?.type === "text_delta" && delta.text) {
        debugLog(`[TEXT_DELTA] calling onTextDelta with: ${delta.text.substring(0, 100)}`);
        callbacks.onTextDelta?.(delta.text);
      }
    }

    // Message start - contains initial input token count
    // Structure: { type: "message_start", message: { usage: { input_tokens, cache_read_input_tokens, ... } } }
    if (inner.type === "message_start") {
      const message = inner.message as { usage?: { input_tokens?: number; cache_read_input_tokens?: number } } | undefined;
      if (message?.usage && state) {
        // Include cache read tokens in input count
        const inputTokens = (message.usage.input_tokens || 0) + (message.usage.cache_read_input_tokens || 0);
        state.inputTokens = inputTokens;
        debugLog(`[TOKEN_UPDATE] message_start: input=${state.inputTokens} output=${state.outputTokens}`);
        callbacks.onTokenUpdate?.(state.inputTokens, state.outputTokens);
      }
    }

    // Message delta - contains output token updates
    // Structure: { type: "message_delta", usage: { output_tokens, ... } }
    if (inner.type === "message_delta") {
      const usage = inner.usage as { input_tokens?: number; output_tokens?: number; cache_read_input_tokens?: number } | undefined;
      if (usage && state) {
        if (usage.output_tokens) {
          state.outputTokens = usage.output_tokens;
        }
        if (usage.input_tokens || usage.cache_read_input_tokens) {
          state.inputTokens = (usage.input_tokens || 0) + (usage.cache_read_input_tokens || 0);
        }
        debugLog(`[TOKEN_UPDATE] message_delta: input=${state.inputTokens} output=${state.outputTokens}`);
        callbacks.onTokenUpdate?.(state.inputTokens, state.outputTokens);
      }
    }
  }

  // Handle result event (final response)
  if (event.type === "result") {
    debugLog(`[RESULT] event received`);
    const usage = event.usage as { input_tokens?: number; output_tokens?: number; cache_read_input_tokens?: number } | undefined;
    if (usage && state) {
      state.inputTokens = (usage.input_tokens || 0) + (usage.cache_read_input_tokens || 0);
      state.outputTokens = usage.output_tokens || state.outputTokens;
      debugLog(`[TOKEN_UPDATE] result: input=${state.inputTokens} output=${state.outputTokens}`);
      callbacks.onTokenUpdate?.(state.inputTokens, state.outputTokens);
    }
  }
}

/**
 * Extended result from Claude CLI including debug data
 */
interface ClaudeCliResult {
  content: string;
  inputTokens: number;
  outputTokens: number;
  cliArgs: string[];
  cliEvents: unknown[];
  toolsCalled: string[];
}

/**
 * Run Claude Code CLI and return the result
 */
async function runClaudeCode(
  systemPrompt: string,
  userPrompt: string,
  cwd: string,
  options: LLMHandoffOptions = {}
): Promise<ClaudeCliResult> {
  const timeout = options.timeout ?? DEFAULT_TIMEOUT;
  const useStreaming = !!options.stream;

  return new Promise((resolve, reject) => {
    let proc: ChildProcess | null = null;
    let timeoutId: ReturnType<typeof setTimeout> | null = null;
    let killed = false;

    // Handle abort signal
    const abortHandler = () => {
      killed = true;
      proc?.kill("SIGTERM");
      reject(new ClaudeCodeError("Cancelled by user"));
    };

    if (options.signal) {
      if (options.signal.aborted) {
        reject(new ClaudeCodeError("Cancelled by user"));
        return;
      }
      options.signal.addEventListener("abort", abortHandler, { once: true });
    }

    const cleanup = () => {
      if (timeoutId) clearTimeout(timeoutId);
      if (options.signal) {
        options.signal.removeEventListener("abort", abortHandler);
      }
    };

    // Build command arguments
    const args = [
      "-p",
      userPrompt,
      "--system-prompt",
      systemPrompt,
      "--output-format",
      useStreaming ? "stream-json" : "json",
      "--allowedTools",
      "Write",  // Only needs Write to save handoff; context is pre-extracted
    ];

    // Add streaming flags
    if (useStreaming) {
      args.push("--verbose");
      args.push("--include-partial-messages");
    }

    debugLog(`[SPAWN] Starting claude with args: ${args.join(" ").substring(0, 200)}...`);
    debugLog(`[SPAWN] useStreaming=${useStreaming} hasStreamCallbacks=${!!options.stream}`);

    proc = spawn("claude", args, {
      cwd,
      stdio: ["pipe", "pipe", "pipe"],
      env: {
        ...process.env,
        // Prevent Jacques hooks from running in subprocess
        JACQUES_SUBPROCESS: "1",
      },
    });

    // IMPORTANT: Close stdin immediately to trigger streaming output
    // Without this, Claude CLI buffers output waiting for input
    proc.stdin?.end();

    debugLog(`[SPAWN] Process started with PID: ${proc.pid}, stdin closed`);

    let stdout = "";
    let stderr = "";
    let streamBuffer = "";
    let accumulatedContent = "";
    const tokenState = { inputTokens: 0, outputTokens: 0 };
    const collectedEvents: unknown[] = []; // Collect ALL events for debugging
    const toolsCalled: string[] = []; // Track tools used during operation

    proc.stdout?.on("data", (data: Buffer) => {
      const chunk = data.toString();
      stdout += chunk;

      if (useStreaming) {
        debugLog(`[STDOUT] received ${chunk.length} bytes`);

        // Parse line-by-line for streaming
        streamBuffer += chunk;
        const lines = streamBuffer.split("\n");
        // Keep the last incomplete line in the buffer
        streamBuffer = lines.pop() || "";

        debugLog(`[STDOUT] ${lines.length} complete lines to parse`);

        for (const line of lines) {
          if (!line.trim()) continue;
          try {
            const event = JSON.parse(line) as Record<string, unknown>;

            // Collect ALL events for debugging
            collectedEvents.push(event);

            handleStreamEvent(event, options.stream, tokenState);

            // Track tool calls
            if (event.type === "stream_event") {
              const inner = event.event as Record<string, unknown> | undefined;
              if (inner?.type === "content_block_start") {
                const block = inner.content_block as { type?: string; name?: string } | undefined;
                if (block?.type === "tool_use" && block.name && !toolsCalled.includes(block.name)) {
                  toolsCalled.push(block.name);
                }
              }
            }

            // Accumulate content from text deltas
            if (event.type === "stream_event") {
              const inner = event.event as Record<string, unknown> | undefined;
              if (inner?.type === "content_block_delta") {
                const delta = inner.delta as { type?: string; text?: string } | undefined;
                if (delta?.type === "text_delta" && delta.text) {
                  accumulatedContent += delta.text;
                }
              }
            }

            // Also capture final result content (fallback)
            if (event.type === "result") {
              const result = event.result as string | undefined;
              if (result && !accumulatedContent) {
                accumulatedContent = result;
              }
            }
          } catch {
            // Ignore malformed JSON lines
          }
        }
      }
    });

    proc.stderr?.on("data", (data: Buffer) => {
      const chunk = data.toString();
      stderr += chunk;
      debugLog(`[STDERR] ${chunk.substring(0, 200)}`);
    });

    proc.on("close", (code) => {
      debugLog(`[CLOSE] Process exited with code: ${code}`);
      debugLog(`[CLOSE] accumulatedContent length: ${accumulatedContent.length}`);
      debugLog(`[CLOSE] tokenState: input=${tokenState.inputTokens} output=${tokenState.outputTokens}`);
      cleanup();

      if (killed) return;

      if (code !== 0) {
        // Try to extract error from stdout if stderr is empty
        let errorMessage = stderr;
        if (!errorMessage && stdout) {
          // Look for error in JSON stream output
          const lines = stdout.split("\n").filter(Boolean);
          for (const line of lines) {
            try {
              const parsed = JSON.parse(line);
              if (parsed.error || parsed.type === "error") {
                errorMessage = parsed.error || parsed.message || JSON.stringify(parsed);
                break;
              }
            } catch {
              // Not JSON, continue
            }
          }
          // If no error found in JSON, show last few lines
          if (!errorMessage) {
            errorMessage = lines.slice(-5).join("\n").substring(0, 1000);
          }
        }
        reject(
          new ClaudeCodeError(
            `Claude Code failed with exit code ${code}: ${errorMessage || "Unknown error"}`,
            code ?? undefined,
            stderr || stdout
          )
        );
        return;
      }

      if (useStreaming) {
        // For streaming, use accumulated content and token state
        resolve({
          content: accumulatedContent,
          inputTokens: tokenState.inputTokens,
          outputTokens: tokenState.outputTokens,
          cliArgs: args,
          cliEvents: collectedEvents,
          toolsCalled,
        });
      } else {
        try {
          // Parse the JSON output
          const response = JSON.parse(stdout);

          // Extract content - Claude CLI returns result field
          const content = response.result || response.text || "";

          // For non-streaming, capture the full response as an event
          collectedEvents.push(response);

          resolve({
            content,
            inputTokens: response.usage?.input_tokens || 0,
            outputTokens: response.usage?.output_tokens || 0,
            cliArgs: args,
            cliEvents: collectedEvents,
            toolsCalled: [], // Non-streaming doesn't track tool calls
          });
        } catch (e) {
          reject(
            new ClaudeCodeError(
              `Failed to parse Claude Code output: ${e instanceof Error ? e.message : String(e)}`
            )
          );
        }
      }
    });

    proc.on("error", (err) => {
      cleanup();
      if (!killed) {
        reject(new ClaudeCodeError(`Failed to spawn Claude Code: ${err.message}`));
      }
    });

    // Set timeout
    timeoutId = setTimeout(() => {
      killed = true;
      proc?.kill("SIGTERM");
      reject(new ClaudeCodeError(`Claude Code timed out after ${timeout / 1000} seconds`));
    }, timeout);
  });
}

/**
 * Generate a handoff document using Claude Code CLI with the jacques-handoff skill.
 *
 * This function:
 * 1. Reads the skill prompt from ~/.claude/skills/jacques-handoff/SKILL.md
 * 2. Passes the transcript path to Claude (it uses Read tool to access it)
 * 3. Claude extracts relevant info and generates the handoff
 * 4. Saves the generated handoff to .jacques/handoffs/
 *
 * @param transcriptPath - Path to the session transcript (JSONL file)
 * @param projectDir - Project directory (for saving the handoff)
 * @param options - Optional timeout and abort signal
 * @returns The generated handoff result with token usage
 */
export async function generateHandoffWithLLM(
  transcriptPath: string,
  projectDir: string,
  options: LLMHandoffOptions = {}
): Promise<LLMHandoffResult> {
  // 1. Read skill prompt
  let skillPrompt: string;
  try {
    skillPrompt = await fs.readFile(SKILL_PATH, "utf-8");
  } catch (err) {
    throw new ClaudeCodeError(
      `Failed to read skill file at ${SKILL_PATH}: ${err instanceof Error ? err.message : String(err)}`
    );
  }

  // 2. Verify transcript exists
  try {
    await fs.access(transcriptPath);
  } catch (err) {
    throw new ClaudeCodeError(
      `Transcript not found at ${transcriptPath}`
    );
  }

  // 3. Pre-extract compact context (rule-based, ~2k tokens instead of 60k)
  // This avoids Claude reading the full transcript file
  const { context: userPrompt, tokenEstimate } = await getCompactContextForSkill(
    transcriptPath,
    projectDir
  );

  debugLog(`[CONTEXT] Pre-extracted compact context: ~${tokenEstimate} tokens`);

  // 4. Run Claude Code CLI with logging
  const operationId = ClaudeOperationLogger.createOperationId();
  const startTime = Date.now();

  // Estimate tokens (~4 chars per token is a rough estimate)
  const userPromptTokensEst = Math.ceil(userPrompt.length / 4);
  const systemPromptTokensEst = Math.ceil(skillPrompt.length / 4);

  // Truncate for preview (first 200 chars)
  const truncate = (s: string, len: number) =>
    s.length > len ? s.substring(0, len) + "..." : s;

  // Log operation START
  const startOperation: ClaudeOperation = {
    id: operationId,
    timestamp: new Date().toISOString(),
    operation: "llm-handoff",
    phase: "start",
    inputTokens: 0,
    outputTokens: 0,
    totalTokens: 0,
    durationMs: 0,
    success: true, // Optimistic
    userPromptChars: userPrompt.length,
    systemPromptChars: skillPrompt.length,
    userPromptTokensEst,
    systemPromptTokensEst,
    userPromptPreview: truncate(userPrompt.replace(/\n/g, " "), 200),
    systemPromptPreview: truncate(skillPrompt.replace(/\n/g, " "), 200),
    // Include full prompts only in debug mode
    ...(ClaudeOperationLogger.isDebugMode() && {
      userPrompt,
      systemPrompt: skillPrompt,
    }),
  };
  await ClaudeOperationLogger.log(startOperation);

  debugLog(`[OPERATION] Started: user=${userPromptTokensEst} tokens est, system=${systemPromptTokensEst} tokens est`);

  let result: ClaudeCliResult;
  let operationSuccess = true;
  let errorMessage: string | undefined;

  try {
    result = await runClaudeCode(skillPrompt, userPrompt, projectDir, options);
  } catch (error) {
    operationSuccess = false;
    errorMessage = error instanceof Error ? error.message : String(error);

    // Log the failed operation
    const failedOperation: ClaudeOperation = {
      id: operationId,
      timestamp: new Date().toISOString(),
      operation: "llm-handoff",
      phase: "complete",
      inputTokens: 0,
      outputTokens: 0,
      totalTokens: 0,
      durationMs: Date.now() - startTime,
      success: false,
      errorMessage,
      userPromptChars: userPrompt.length,
      systemPromptChars: skillPrompt.length,
      userPromptTokensEst,
      systemPromptTokensEst,
      // Include full prompts only in debug mode
      ...(ClaudeOperationLogger.isDebugMode() && {
        userPrompt,
        systemPrompt: skillPrompt,
      }),
    };
    await ClaudeOperationLogger.log(failedOperation);

    throw error;
  }

  const durationMs = Date.now() - startTime;

  // Calculate overhead (input tokens - estimated prompt tokens)
  const promptTokensEst = userPromptTokensEst + systemPromptTokensEst;
  const overheadTokens = result.inputTokens - promptTokensEst;

  // Save debug data (always, for inspection)
  const debugData: ClaudeOperationDebug = {
    operationId,
    timestamp: new Date().toISOString(),
    userPrompt,
    systemPrompt: skillPrompt,
    cliArgs: result.cliArgs,
    cliEvents: result.cliEvents,
    response: result.content,
  };
  const debugFilePath = await ClaudeOperationLogger.saveDebugData(debugData);
  debugLog(`[DEBUG] Saved debug data to: ${debugFilePath}`);

  // Log the successful operation COMPLETE
  const completeOperation: ClaudeOperation = {
    id: operationId,
    timestamp: new Date().toISOString(),
    operation: "llm-handoff",
    phase: "complete",
    inputTokens: result.inputTokens,
    outputTokens: result.outputTokens,
    totalTokens: result.inputTokens + result.outputTokens,
    durationMs,
    success: true,
    userPromptChars: userPrompt.length,
    systemPromptChars: skillPrompt.length,
    userPromptTokensEst,
    systemPromptTokensEst,
    outputLength: result.content.length,
    toolsCalled: result.toolsCalled.length > 0 ? result.toolsCalled : undefined,
    // Include full prompts only in debug mode
    ...(ClaudeOperationLogger.isDebugMode() && {
      userPrompt,
      systemPrompt: skillPrompt,
    }),
  };
  await ClaudeOperationLogger.log(completeOperation);

  debugLog(`[OPERATION] Complete: ${result.inputTokens} in (est: ${promptTokensEst}, overhead: ${overheadTokens}), ${result.outputTokens} out, ${durationMs}ms`);
  if (result.toolsCalled.length > 0) {
    debugLog(`[TOOLS] Called: ${result.toolsCalled.join(", ")}`);
  }

  // 5. Save handoff file
  const handoffsDir = await ensureHandoffsDir(projectDir);
  const filename = generateHandoffFilename();
  const filePath = join(handoffsDir, filename);

  await fs.writeFile(filePath, result.content, "utf-8");

  return {
    filePath,
    filename,
    content: result.content,
    inputTokens: result.inputTokens,
    outputTokens: result.outputTokens,
    totalTokens: result.inputTokens + result.outputTokens,
  };
}

/**
 * Check if the jacques-handoff skill is installed
 */
export async function isSkillInstalled(): Promise<boolean> {
  try {
    await fs.access(SKILL_PATH);
    return true;
  } catch {
    return false;
  }
}

/**
 * Get the path to the jacques-handoff skill
 */
export function getSkillPath(): string {
  return SKILL_PATH;
}
