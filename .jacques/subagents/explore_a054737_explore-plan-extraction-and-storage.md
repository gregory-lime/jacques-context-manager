# Explore: Explore plan extraction and storage

> Session: `03949068-ed82-4b1d-a83f-fbf5add62caf`
> Date: 2026-02-03
> Tokens: ~76 101

---

Perfect! Now I have a comprehensive understanding. Let me create a detailed report for the user:

## Comprehensive Exploration: Plan Extraction, Storage, and Deduplication System

Based on my thorough analysis of the Jacques codebase, here's a complete breakdown of how the plan system works:

---

## 1. PLAN DETECTION & EXTRACTION

### Detection Mechanisms

**Embedded Plan Detection** (`core/src/archive/plan-extractor.ts`)
- Scans **user messages only** (ignores assistant/system messages)
- Uses three trigger patterns (case-insensitive):
  - `"implement the following plan:"`
  - `"here is the plan:"`
  - `"follow this plan:"`
- Validation requirements:
  - Content **after** trigger phrase must be ≥100 characters (critical: not including the trigger itself)
  - Must contain at least one markdown heading (`#`)
  - Multiple plans extracted if separated by top-level headings (`^# `)

**Write Tool Plan Detection** (`core/src/archive/manifest-extractor.ts`)
- Detects plans written via the Write tool
- Searches for files in:
  - `~/.claude/plans/` (configured plansDirectory)
  - Any path containing `/plans/` or ending with `.md` and containing "plan"
- Source: `"write"` (to differentiate from embedded)

### Trigger Points

Plans are extracted in **two contexts**:

1. **Save Context (Manual)**: When user saves a session via `/Save Context` command
2. **Archive on Session End (Auto)**: When SessionEnd hook fires

Both flow through `extractManifestFromEntries()` in `manifest-extractor.ts`, which calls both:
- `detectPlans()` → finds Write tool plans
- `extractEmbeddedPlans()` → finds embedded plans

---

## 2. PLAN STORAGE HIERARCHY

### Storage Locations

**Local Project** (`.jacques/plans/`)
```
.jacques/
├── plans/
│   ├── 2026-02-01_archive-browser-implementation-plan.md
│   ├── 2026-02-01_plan-fix-llm-handoff-to-use-compact-context.md
│   └── ...
└── index.json  (unified project index - tracks all plans with session links)
```

**Global Archive** (`~/.jacques/archive/plans/`)
```
~/.jacques/archive/
└── plans/
    └── [projectId]/  (encoded project path, e.g., "-Users-gole-Desktop-jacques-context-manager")
        ├── 2026-02-01_archive-browser-implementation-plan.md
        └── ...
```

### Filename Format

**Generated by `generatePlanFilename()`:**
```
YYYY-MM-DD_title-slug.md
Example: 2026-02-01_archive-browser-implementation-plan.md
```

- Date: From file modification time (or current date for embedded)
- Title: Extracted from first markdown heading (`^# `)
- Slug: Lowercase, alphanumeric + dashes, max 50 chars

### Naming Collision Handling

**Versioning strategy** (`generateVersionedFilename()`):
```
Original:  2026-02-01_auth-system.md
Collision: 2026-02-01_auth-system-v2.md
Next:      2026-02-01_auth-system-v3.md
```

---

## 3. DEDUPLICATION STRATEGY

### Three-Level Deduplication

**Level 1: Exact Hash Match**
```typescript
// SHA-256 hash of normalized content
contentHash = SHA256(
  content.replace(/\s+/g, " ").toLowerCase()
)
// Whitespace-insensitive: "plan A" === "plan  A"
```

**Level 2: Fuzzy Match (Title + Length + Similarity)**
```typescript
// All THREE must match:
✓ titleNormalized === "auth-system" (slugified, lowercased)
✓ lengthRange === "501-2000"     (content grouped into buckets)
✓ similarity >= 0.9               (Jaccard word overlap)

// Similarity = intersection(words) / union(words)
// Filters: only words > 3 characters
```

**Level 3: Within-Session Deduplication**
```typescript
// Track hashes seen in current extraction
seenHashes = Set<string>
if (seenHashes.has(fingerprint)) skip  // Don't extract duplicate in same message
```

### Deduplication Flow

1. **During extraction** (`extractEmbeddedPlans()`):
   - Check within-session duplicates (seenHashes)
   - Call `findDuplicatePlan()` to search catalog

2. **If duplicate found**:
   - Reuse existing plan file
   - Call `indexEmbeddedPlan()` with duplicate's filename
   - Merge session IDs: `[...new Set([...existing.sessions, newSessionId])]`

3. **If unique**:
   - Generate new filename
   - Check for filename collision (different content, same name)
   - Create versioned filename if collision
   - Write file and index it

### Example from `.jacques/index.json`

```json
{
  "id": "2026-02-01_archive-browser-implementation-plan",
  "title": "Archive Browser Implementation Plan",
  "filename": "2026-02-01_archive-browser-implementation-plan.md",
  "path": "plans/2026-02-01_archive-browser-implementation-plan.md",
  "createdAt": "2026-02-01T15:55:29.800Z",
  "updatedAt": "2026-02-01T15:55:29.800Z",
  "sessions": [
    "1cb8c55b-432d-4870-8a0a-7c9147f9b8ba",
    "21ea55e2-80bc-4adb-bf99-47e013418abf"  // Multiple sessions linked
  ]
}
```

---

## 4. PLAN REFERENCES IN MANIFESTS

Plans appear in the `ConversationManifest` (saved to archive) with full metadata:

```typescript
export interface PlanReference {
  path: string;              // Absolute path for file reading
  name: string;              // Filename (e.g., "plan.md")
  archivedPath: string;      // Archive-relative path (e.g., "plans/plan.md")
  source: "embedded" | "write";  // Detection source
}
```

**Combining Both Sources** (`manifest-extractor.ts`):
```typescript
const writePlans = detectPlans(entries);        // Write tool
const embeddedPlans = await extractEmbeddedPlans(entries, projectPath, sessionId);
const plans = [...writePlans, ...embeddedPlans];  // Merged in manifest
```

---

## 5. ARCHIVE INTEGRATION

### Full Save Context Flow

1. **User presses [S]** (Save Context) in GUI
2. **`saveToArchive()`** called with entries
3. **Extract manifest** → `extractManifestFromEntries()`
   - Detects embedded plans in session
   - Detects Write tool plans
   - Returns manifest with `plans[]` array
4. **Archive conversation** → `archiveConversation()`
   - Saves manifest to `~/.jacques/archive/manifests/{id}.json`
   - Saves conversation to `~/.jacques/archive/conversations/{projectId}/{id}.json`
   - **Archives plans** (step 5)
   - Updates global search index
5. **Archive each plan**:
   ```typescript
   for (const planRef of manifest.plans) {
     // Check if already archived
     if (isPlanArchived(projectId, filename)) {
       updatePlanSessionLink()  // Just add session ID
     } else {
       archivePlan()  // Copy to archive + update index
     }
   }
   ```

### Plan Archiving Process

**`archivePlan()` function** handles:
1. Read plan content from absolute path
2. Generate readable filename (with actual title from heading)
3. Copy to global: `~/.jacques/archive/plans/{projectId}/filename.md`
4. Optionally copy to local: `.jacques/plans/filename.md`
5. Update unified project index (`.jacques/index.json`) with session link

---

## 6. DIFFERENCES: EMBEDDED vs WRITE PLANS

| Aspect | Embedded Plans | Write Tool Plans |
|--------|---|---|
| **Detection** | User message pattern matching | Write tool call scanning |
| **Storage** | `.jacques/plans/` created on archive | Wherever user wrote them |
| **Indexing** | Automatic deduplication | Only during manifest extraction |
| **Session Link** | Created immediately via `indexEmbeddedPlan()` | Created during archive via `archivePlan()` |
| **Trigger** | Plan trigger phrases in messages | Write tool usage |
| **Validation** | ≥100 chars, has heading | Any path matching patterns |
| **Source Field** | `"embedded"` | `"write"` |

### Key Distinction

**Embedded plans** are extracted AND indexed during session while executing `extractEmbeddedPlans()`:
- File written to `.jacques/plans/`
- Index entry created immediately
- Session link established

**Write plans** are only detected during archive extraction:
- Remain in original location
- Detected when manifest is built
- Archived during `archiveConversation()`

---

## 7. KEY IMPLEMENTATION DETAILS

### Fingerprinting Components

```typescript
export interface PlanFingerprint {
  contentHash: string;        // SHA-256 of normalized content
  titleNormalized: string;    // Title converted to slug
  lengthRange: string;        // "0-500" | "501-2000" | "2001+"
}
```

### Error Handling

**Non-blocking in `extractEmbeddedPlans()`:**
```typescript
try {
  // extraction logic
} catch (error) {
  console.error("Failed to extract embedded plan:", {
    error: error.message,
    planContent: planContent.substring(0, 100) + "...",
    projectPath,
    sessionId,
  });
  // Continue processing other plans - don't fail the entire archive
}
```

### Session-Plan Bidirectional Links

Through `.jacques/index.json`:
- Plans track which sessions used them: `sessions: string[]`
- Sessions appear in `ConversationManifest.plans[]`
- Handoff documents include "Plan Context" section

---

## 8. STORED PLAN FILES EXAMPLE

From actual codebase (`.jacques/plans/2026-02-01_archive-browser-implementation-plan.md`):

```markdown
# Archive Browser Implementation Plan

## Overview

Add an Archive Browser feature to **both** the Jacques CLI dashboard and web GUI:

1. **CLI Dashboard** (Ink/React TUI): Settings button to initialize archive
2. **Web GUI** (React): Full archive browser with search and conversation viewer
3. **Core**: Bulk archiving functions shared by both interfaces

## Files to Create

### 1. `core/src/archive/bulk-archive.ts`
...
```

This is a full markdown document with:
- Markdown headings for structure
- Detailed implementation steps
- Clear organization

---

## 9. TESTS & VALIDATION

The system has **37 comprehensive unit tests** in `core/src/archive/plan-extractor.test.ts`:

- **Detection**: Case-insensitivity, multiple plans per message, validation rules
- **Deduplication**: Hash consistency, fuzzy matching with similarity threshold
- **Indexing**: Session ID merging, duplicate prevention
- **Full flow**: Extraction, error handling

Key test insights:
- Fuzzy matching with `similarity >= 0.9` is strict (near-identical required)
- Plans without headings are rejected
- Content must exceed 100 chars AFTER trigger phrase removal
- Multiple plans split by `^#` headings in single message

---

## 10. CURRENT STATE IN CODEBASE

From `.jacques/index.json`, there are **10 plan entries** tracking:
- Which sessions created them
- When they were created/updated
- Bidirectional session-plan relationships

Plans are actively being created and deduplicated as sessions are archived.